//****************************INCLUDE******************************************
#include "stm32f10x.h"
#include "SPI.h"
#include "system.h"
#include "stm32f10x_gpio.h"
//***************************LOCAL VAR*****************************************
static uint8_t	        SPI_USER = SPI_USER_txOk;               // Регистр флажков
static uint8_t          SPI_TX_COUNT = 0;			// Счетчик буфера на отправку
static uint16_t         SPI_TX_BUFFER[SPI_BUFFER_SIZE];		// Буфер на отправку
static uint8_t		SPI_TX_LEN = 0;				// Длинна отправляемого сообщения
#if (SPI_INPUT)                                                 // Если разрешен прием данных
  static uint8_t        SPI_RX_COUNT = 0;			// Счетчик буфера на прием
  static uint16_t       SPI_RX_BUFFER[SPI_BUFFER_SIZE];		// Буфер на прием
#endif
//***************************FUNCTIONS*****************************************
void SPI1_IRQHandler(void);             // Прерывание по окончанию передачи пакета
//*****************************************************************************
//***************************User code*****************************************
//*****************************************************************************
void SPI_init(uint8_t bit16)
{
  GPIO_InitTypeDef      GPIO_InitStruct;                        // Структура инициализирующих данных GPIO
  //********************************RCC*****************************************
  RCC->APB2ENR |= RCC_APB2ENR_AFIOEN|RCC_APB2ENR_IOPAEN;        // Включаем тактирование порта и альтернативных функций
  //********************************GPIO****************************************
  GPIO_InitStruct.GPIO_Pin   = SCLK_pin | MOSI_pin;             // Передающие пины
  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;                // Макс скорость
  GPIO_InitStruct.GPIO_Mode  = GPIO_Mode_AF_PP;                 // Альтернативная функция SPI
  GPIO_Init(SPI_port, &GPIO_InitStruct);                        // Инициализируем передающие пины
  GPIO_InitStruct.GPIO_Pin =  MISO_pin;                         // Принимающий пин
  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;            // Альтернативная функция SPI
  GPIO_Init(SPI_port, &GPIO_InitStruct);                        // Иницализируем пин
  GPIO_InitStruct.GPIO_Pin = CS_pin;                            // Настройки вывода
  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;                 // Режим выхода без подтягивающих резисторов
  GPIO_Init(SPI_port, &GPIO_InitStruct);                        // Заданные настройки сохраняем в регистрах
  CS_RESET;                                                     // Опускаем чипселект
  //*********************SPI INIT*********************************
  RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;   // Включаем тактирование SPI
  NVIC_EnableIRQ(SPI1_IRQn);	        // Разрешаем прерывания по SPI
  NVIC_SetPriority(SPI1_IRQn, 3);       // Устанавливаем приоритет индикации
  SPI->CR1 &= ~SPI_CR1_BR;              // Делитель частоты = 2 (макс. скорость)
  SPI->CR1 |= SPI_CR1_SSM;              // Перходим в программное управление чип селектом
  SPI->CR1 |= SPI_CR1_SSI;              // Запрещаем брать инфу с ног
  if(bit16)                             // Если передает 16-битные сообщения
  {
    SPI->CR1 |= SPI_CR1_DFF;	        // 16-бит сообщение
  }
  SPI->CR1 |= SPI_CR1_MSTR;             // Мастер
  SPI->CR1 |= SPI_CR1_SPE;              // Включаем SPI
  #if (SPI_INPUT)                       // Если разрешен прием данных
    SPI->CR2 |= SPI_CR2_RXNEIE;		// Разрешаем прерывание по приему
  #endif
}



//*************SPI_Send**************
// Input:
// 	data - указатель на массив данных
//	len  - длина сообщения
//***********************************
void SPI_Send(uint16_t* data, uint8_t len)
{
  uint8_t i;
  CS_RESET;					// Опускаем чип-селект на прием данных
  for(i=0;i<len;i++)                            // Пробегаем по всей длине буфера
  {     
    SPI_TX_BUFFER[i] = data[i];	                // Записываем данные в буфер
  }
  SPI_TX_LEN   = len;				// Записываем длинну сообщения
  SPI_TX_COUNT = 1;				// Збрасываем указатель в буфере
  SPI_USER    &= ~SPI_USER_txOk;		// Сбрасываем флаг окончания передачи
  SPI->DR      = SPI_TX_BUFFER[0];		// Засылаем первый пакет для срабатывания прерывания
  SPI->CR2    |= SPI_CR2_TXEIE;			// Разрешаем прерывание по окончанию передачи
  return;
}
//***********************************




//************SPI_IsTxEnd************
// Output:
// 0 - передача окончена
// 1 - передача в процессе
//***********************************
uint8_t SPI_IsTxEnd(void)
{
  return (SPI_USER&SPI_USER_txOk);
}
//***********************************


//*************SPI_IsRx**************
// Output:
// 0 - на прием что-то есть
// 1 - пусто
//***********************************
uint8_t SPI_IsRx(void)
{
  uint8_t res = SPI_USER & SPI_USER_rxOk;
  SPI_USER   &= ~SPI_USER_rxOk;
  return res;
}
//***********************************


//***********SPI_TestLine************
//   Тестирование линии и вычисление
// кол-ва устройств на линии
//***********************************
// Output:
//  0      - устройств на линии нет, 
//           MOSI закорочен на MISO
//  1..254 - линия работает
//  255    - устройства не найдены 
//           или цепь не циклична
//*********************************** 
uint8_t SPI_TestLine(void)
{
  // NB: Не работает!!!
  uint16_t i,j,buf;
  CS_RESET;				// Опускаем чип-селект на прием данных
  for(i=0;i<SPI_MaxOnLine+2;i++)
  {
    SPI->DR = 0;
    while(!(SPI->SR&SPI_SR_TXE));
  }
  for(i=1;i<(SPI_MaxOnLine+2);i++)	// Прогоняем сообщения по кол-ву устройств на линии + последнее на прием.
  {
    SPI->DR = i;
    while(!(SPI->SR&SPI_SR_TXE));
    Delay_ms(100);
    for(j=0;j<SPI_TIMOUT;j++)		// Ждем прием посылки 
    {
      if (SPI->SR&SPI_SR_RXNE && (SPI->DR > 0))	// Если пришли данные
      {
        buf = SPI->DR;	        // Читаем
        if (i == buf) 
        {
          return 0;             // Если мы на первой посылке - устройств нет, MISO закорочен на MOSI
        }
        else 
        {
          return (i-1);	// Во всех других случаях мы нашли кол-во устройств
        }
      }
    }
  }
  return 0xFF;  // Если досчитали до конца - все плохо.
}
//***********************************




//*****************************************************************************
//************************Interrupt routine************************************
//*****************************************************************************
void SPI1_IRQHandler(void)
{
  #if (SPI_IRQ_DIS)
    __disable_irq ();            // Глобальный запрет прерываний
  #endif
  //****************************OUTPUT*****************************************
  if(SPI->SR &= SPI_SR_TXE)			// Прерывание по окончанию отправки
  {
    if(SPI_TX_COUNT < SPI_TX_LEN)		// Если еще не все отправили
    {
      SPI->DR = SPI_TX_BUFFER[SPI_TX_COUNT];	// Отправляем очередной пакет
      SPI_TX_COUNT++;				// Инкрементируем счетчик буфера
    }
    else 					// Если буфер закончился и последний пакет ушел
    {
      SPI->CR2 &= ~SPI_CR2_TXEIE;		// Запрещаем прерывание по готовности на передачу
      SPI_USER |= SPI_USER_txOk;		// Выставляем успех
      CS_SET;					// Выставляем чип селект
    }
  }
  //*****************************INPUT*****************************************
  #if (SPI_INPUT)                               // Если разрешен прием данных
    if(SPI->SR &= SPI_SR_RXNE)			// Прерывание по приему
    {
      SPI_RX_BUFFER[SPI_RX_COUNT] = SPI->DR;	// Записываем пакет в буфер
      SPI_RX_COUNT++;			        // Инкрементируем счетчик буфера
      SPI_USER |= SPI_USER_rxOk;		// Выставляем флаг не пустого буфера
    }
  #endif
  //***************************************************************************
  WatchDog_reset();             // Сбрасываем вачдог
  #if (SPI_IRQ_DIS)
    __enable_irq ();            // Глобальное разрешение прерываний
  #endif
  return;
}
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************