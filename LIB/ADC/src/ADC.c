//****************************INCLUDE******************************************
#include "stm32f10x.h"
#include "ADC.h"
#include "system.h"
#include "stm32f10x_gpio.h"
//***************************LOCAL VAR*****************************************
static uint16_t 	ADC_BUFFER[ADC_CH_NUM] = {0,0,0,0};     // Буфер данных АЦП на 4 канала
static uint8_t		ADC_CurAIN = 0;				// Текущий измерямый канал
static uint8_t		ADC_AinOk = 1;				// Преобразования закончены
//*****************************CONST*******************************************
const uint8_t    	ADC_Chs[ADC_CH_NUM] = {AIN0,AIN1,AINT,AINV};	// Перечень каналов
//***************************FUNCTIONS*****************************************
void ADC1_2_IRQHandler(void);
//*****************************************************************************
//***************************User code*****************************************
//*****************************************************************************
uint8_t ADC_init(void)
{
  GPIO_InitTypeDef      GPIO_InitStruct;                // Структура инициализирующих данных GPIO
  //**********************************RCC***************************************
  RCC->APB2ENR |= RCC_APB2ENR_IOPAEN|RCC_APB2ENR_ADC1EN;// Включаем тактирование порта A и АЦП
  //***********************************AIN**************************************
  GPIO_StructInit(&GPIO_InitStruct);                    // Чистим структура инициализации
  GPIO_InitStruct.GPIO_Pin   = AIN0_pin|AIN1_pin;       // Иницилизируем пины
  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;        // Скорость порта максимальная
  GPIO_InitStruct.GPIO_Mode  = GPIO_Mode_AIN;           // Режим аналогового входа
  GPIO_Init(AIN_port, &GPIO_InitStruct);                // Заданные настройки сохраняем в регистрах
  //*********************************ADC****************************************
  RCC->CR |= RCC_CR_HSION;		// Включаем тактирование HSI
  while(!(RCC->CR & RCC_CR_HSIRDY));	// Дожидаемся включения HSI  
  ADC->CR1     |= ADC_CR1_EOCIE;	// Разрешаем прерывание по окончанию преобразования
  ADC->CR2     |= ADC_CR2_EXTSEL;       // Запуск по SWSTART
  ADC->CR2     &= ~ADC_CR2_CONT;	// Одиночное преобразование
  ADC->CR2     &= ~ADC_CR2_ALIGN;       // Выравнивание в право
  ADC->CR2     |= ADC_CR2_TSVREFE;      // Разрешаем измерение температуры кристала
  ADC->SQR1    &= ~ADC_SQR1_L;          // 1 преобразование в последовательности
  ADC->SMPR2   |= ADC_SMPR2_SMP0_2 |	// 41.5 такта выборки на 0-ой канал
                  ADC_SMPR2_SMP1_2;	// 41.5 такта выборки на 1-ый канал
  ADC->SMPR1   |= ADC_SMPR1_SMP16_2 |	// 41.5 такта выборки на 16-ый канал
		  ADC_SMPR1_SMP17_2;    // 41.5 такта выборки на 17-ый канал
  ADC->CR2     |= ADC_CR2_ADON;		// Включаем АЦП
  Delay_ms(1);                          // Ждем прохождения мин. 2 тактов АЦП
  ADC->CR2     |= ADC_CR2_CAL;          // Запускаем калибровку АЦП
  while (!(ADC->CR2 & ADC_CR2_CAL));    // Ожидаем окончание калибровки
  #ifdef STM32F10X_MD
    NVIC_EnableIRQ(ADC1_2_IRQn);	// Разрешаем прерывания по ADC 1
  #endif
  #ifdef STM32F10X_LD_VL
    NVIC_EnableIRQ(ADC1_IRQn);		// Разрешаем прерывания по ADC 1
  #endif
  //********************************GET DATA************************************
  ADC_SET_CH(AIN0);		        // Выбираем канал температуры
  ADC_SR_CLC;			        // Сбрасываем флажки
  ADC_START;			        // Запускаем преобразование
  while (!ADC_FINISH);		        // Ожидаем конец преобразования
  if (ADC->DR > 0) return 1;    
  else return 0;
}

//**********ADC_StartScan**********
// Запуск измерения. Читать можно
// после ADC_AinOk == 1
//*********************************
void ADC_StartScan(void)
{
  ADC_SR_CLC;                   // Стираем флажки состояния АЦП
  ADC_AinOk  = 0;               // Сбрасываем флаг готовности измерений
  ADC_CurAIN = 1;               // Выставляем второй канал для следующего измерения
  ADC_SET_CH(ADC_Chs[0]);       // Выставляем первый канал для текущего измерения
  ADC_START;                    // Запускаем АЦП
  return;
}
//*********************************


//*********************************
uint8_t ADC_ConvEnd(void)
{
  return ADC_AinOk;
}
//*********************************


//***********ADC_GetData***********
// Возвращает данные в следующих размерностях:
// AIN0 - В*10^-2
// AIN1 - В*10^-2
// AIN2 - 'C
// AIN3 - В*10^-2
//*********************************
void ADC_GetData(uint16_t* data)
{
  data[0] = (uint16_t)((float)ADC_BUFFER[0]*Vref*Kf0*100 / 0x0FFF);
  data[1] = (uint16_t)((float)ADC_BUFFER[1]*Vref*Kf1*100 / 0x0FFF);
  data[2] = (uint16_t)(ADC_CALC_TEMP(ADC_BUFFER[2]));
  data[3] = (uint16_t)((float)ADC_BUFFER[3]*Vref*100 / 0x0FFF);
  return;
}
//*********************************


//*****************************************************************************
//************************Interrupt routine************************************
//*****************************************************************************
void ADC1_IRQHandler(void)
{
  __disable_irq ();                             // Глобальный запрет прерываний
  if (ADC_FINISH)                               // Если причина прерывания конец преобразования...
  {
    ADC_SR_CLC;                                 // Очизаем флаги состояния АЦП
    ADC_BUFFER[ADC_CurAIN-1] = ADC->DR;         // Записываем результат измерений в буфер
    if(ADC_CurAIN < ADC_CH_NUM)                 // Если не пробежались по всем каналам...
    {
      ADC_SET_CH(ADC_Chs[ADC_CurAIN]);          // Меняем измеряемый канал
      ADC_START;                                // Запускаем измерение
      ADC_CurAIN++;                             // Инкрементируем номер следующего канала
    }
    else ADC_AinOk = 1;                         // Если закончили - выставляем флаг окончания измерений
  }
  WatchDog_reset();                             // Сбрасываем вачдог
  __enable_irq ();                              // Глобальное разрешение прерываний
  return;
}
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************