#include "HD44780.h"
#include "DIO.h"
#include "PWM.h"
#include "system.h"
#include "stm32f10x.h"
#include <stdlib.h>
#include <stdio.h>
#include "stm32f10x_gpio.h"
#include "stm32f10x_tim.h"
//***************************Local function************************************
void    HD_WriteByte(uint16_t n);       // Обработка записи данных из буфера
void    LCD_init(void);                 // Инициализация параметров LCD экрана
uint8_t HD_ReadBusy(void);              // Чтение бизи флаг дисплея
//***************************Global VAR****************************************
static uint16_t         HD_BUFFER[HD_BUFFER_SIZE];      // 0-7 - данные, 8-RS, 9 - RnW
static uint16_t         HD_COUNT      = 0;              // Счетчик в буфере
static uint16_t         HD_BUF_LEN    = 0;              // Длинна данных в буфере
static uint32_t         HD_LATCH_TIME = 0;              // Счетчик удержания защелки


static uint8_t          HD_USER    = 0;                 // Пользовательский регистр
static uint16_t         HD_CURSOR  = 0;                 // Координату курсора 

volatile uint8_t*       HD_DATA_PORT = (uint8_t*)&(Data_port->ODR);     // Указатель на порт, куда писать данные
//****************************CONST********************************************

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************



//*****************************************************************************
// Запись последовательности настроек дисплея в буфер, в соответсвии с дефай-
// нами из .h файла
//*****************************************************************************
void LCD_init(void)
{
  // Записываем основу для конфигурирования
  
  HD_BUFFER[0] = HD_CMD_FS;
  HD_BUFFER[1] = HD_CMD_DOC | HD_CMD_DOC_DO;    // Включаем устройства
  HD_BUFFER[2] = HD_CMD_MS;                     // Автоскрол, направление записи данных
  HD_BUFFER[3] = HD_CMD_CD;                     // Очистка дисплея
  HD_BUFFER[4] = HD_CMD_RH;                     // Возврат каретки
  //***************HD_CMD_MS***************
  if (LCD_AutoScroll)
  {
    HD_BUFFER[2] |= HD_CMD_MS_AS;               // Автоскрол
  }
  if (LCD_ScrollLeftToRight)
  {
    HD_BUFFER[2] |= HD_CMD_MS_LR;               // Слева направо
  }
  //***************HD_CMD_DOC**************
  if(LCD_Cursor)
  {
    HD_BUFFER[1] |= HD_CMD_DOC_CO;              // Включаем курсор
  }
  if(LCD_Blink)
  {
    HD_BUFFER[1] |= HD_CMD_DOC_BO;              // Включаем мигание курсора
  }
  //***************HD_CMD_FS***************
  if(LCD_8bit)
  {
    HD_BUFFER[0] |= HD_CMD_FS_8BDL;             // 8 бит шина данных
  }
  if(LCD_2lines)
  {
    HD_BUFFER[0] |= HD_CMD_FS_N;                // В дисплее 2 полосы
  }
  if(LCD_5x10)
  {
    HD_BUFFER[0] |= HD_CMD_FS_F;                // Размер символа в пикселях
  }
  return;
}
//*****************************************************************************






//*****************************************************************************
// Запуск записи массива данных в дисплей посредством параллельного порта
//*****************************************************************************
// data - указатель на массив данных
// len  - длинна массива 
//*****************************************************************************
void HD_Write(uint16_t* data,uint16_t len)
{
  uint16_t i;
  E_reset;
  for(i=0;i<len;i++)                                    // Копируем данные в буфер
  {
    HD_BUFFER[i] = data[i];
  }
  HD_BUF_LEN = len;
  HD_COUNT   = 0;                                 // Сбрасываем счетчик буффера
  HD_USER   |= (HD_USER_START | HD_USER_BUSY);    // Выставляем флаг готовности к записи и занятости устройства
  
  return;
}

void HD_Proc(void)
{
  if ((HD_USER & HD_USER_LATCH) && (HD_LATCH_TIME > HD_LATCH_TIMEOUT))          // Орабатываем поднятую защелку
  {
    E_reset;                                                                    // Сбрасываем защелку
    HD_USER &= ~HD_USER_LATCH;                                                  // Сбрасываем флаг
    HD_LATCH_TIME = 0;
  }
  else if ((HD_USER & HD_USER_DATA) && (HD_LATCH_TIME > HD_LATCH_TIMEOUT))
  {
    HD_USER &= ~HD_USER_DATA;
    HD_LATCH_TIME = 0;
  }
  
  else if ((HD_USER & HD_USER_START) && (!(HD_USER & HD_USER_DATA)))                                            // Обрабатываем очередной байт данных
  {
    if (HD_BUFFER[HD_COUNT] & HD_BUFFER_RS_MSK)
    {
      RS_set;
    }
    else
    {
      RS_reset;
    }
    *HD_DATA_PORT = (uint8_t)(HD_BUFFER[HD_COUNT] & HD_BUFFER_DATA_MSK);        // Отправляем в порт очередной байт
    E_set;                                                                      // Поднимаем защелку
    HD_USER |= HD_USER_LATCH | HD_USER_DATA;                                    // Выставляем флаг защелки и отправленных данных
    HD_LATCH_TIME = 0;                                                          // Сбрасываем счетчик защелки
    if (HD_COUNT < HD_BUF_LEN)                                                  // Если сообщение еще не закончилось...
    {
      HD_COUNT++;                                                               // Инкрементируем счетчик
    }
    else
    {
      HD_USER &= ~HD_USER_START;                                                // Сбрасываем флажек отправки сообщений
    }
  }
  
  else if ((!(HD_USER & HD_USER_LATCH)) && (!(HD_USER & HD_USER_START)))        // Если  сообщения закончились и защелку обработана
  {     
    HD_USER &= ~HD_USER_BUSY;                                                   // Снимаеим флаг занятости
  }
  
  HD_LATCH_TIME++;
  
  return;
}
//*****************************************************************************


//*****************************************************************************
// Запись очередного байта из буффера
//*****************************************************************************
// n - номер байта запись
//*****************************************************************************
void HD_WriteByte(uint16_t n)
{
  uint16_t data = HD_BUFFER[n];                         // Читаем из буфера нужную строку
  
  if (data & HD_BUFFER_RS_MSK)                          // Читаем запись команды или данных
  {
    RS_set;                                             // Переходим в режим записи данных
  }
  else
  {
    RS_reset;                                           // Переходим в режим команд
  }
  *HD_DATA_PORT = (uint8_t)(data & HD_BUFFER_DATA_MSK); // Укладываем данные в порт
  E_invert;                                             // Поднимаем защелку
  HD_USER |= HD_USER_LATCH;                             // Выставляем флаг защелки 
  return;
}
//*****************************************************************************


//*****************************************************************************
// Возращает статус занятости потока дисплея
//*****************************************************************************
uint8_t HD_GetBusy(void)
{
  return (HD_USER & HD_USER_BUSY);
}
//*****************************************************************************

//*****************************************************************************
// Чтение из дисплея статус окончания записи данных
//*****************************************************************************
uint8_t HD_ReadBusy(void)
{
  uint8_t busy = 0;
  
  DIN_Init(Data_pins,Data_port);
  RnW_set;
  if (Busy_Read)
  {
    busy = 1;
  }
  DOUT_Init(Data_pins,Data_port);
  RnW_reset;
  return busy;
}
//******************************************************************************
//******************************************************************************
//******************************************************************************
void HD_init(void)
{  
  //*****************************GPIO******************************************
  DOUT_Init(Data_pins,Data_port);                       // Инициализируем пины данных
  DOUT_Init(Sys_pins,Sys_port);                         // Инициализируем системные пины
  //PWM_Inin(LedOn_pin,LedOn_port,LedOn_tim,LedOn_ch);    // Инициализируем пин установки яркости подсветки
  //PWM_Inin(V0_pin,V0_port,V0_tim,V0_ch);                // Инициализируем пин установки контраста экрана
  //***************************START COND**************************************
  RS_reset;                                             // Переходим в режим установки
  RnW_reset;                                            // Переходим в режим записи
  E_reset;                                              // Сбрасываем тактирование
  Delay_ms(100);                                        // Ждем пока проснеться
  //******************************LCD******************************************
  LCD_init();                                           // Инициализация параметров для конкретного дисплея (см. дефайны)
  HD_Write(HD_BUFFER,LCD_InitLen);                      // Пишим последовательность инициализации LCD
  HD_CURSOR = 0;                                        // Сброс положения курсора
  HD_SetBackLight(0);                                   // Тушим подсветку
  while (HD_GetBusy()){}
  //***************************************************************************
  return;
}
//******************************************************************************
//******************************************************************************
//******************************************************************************







//******************************************************************************
//***********************************SERVIS*************************************
//******************************************************************************
// Здвиг курсора
// step - кол-во символов на сдвиг
// RnL - направление: 1 - вправо, 0 - влево
void HD_DispShift(uint16_t step, uint8_t RnL)
{
  uint16_t i;
  uint16_t data = HD_CMD_CDS|HD_CMD_CDS_DS;
  if (RnL)                      // RnL = 1 - вправо, RnL - влево
  {
    data |= HD_CMD_CDS_RS;      // Добавляем правое направление
    HD_CURSOR += step;          // Вправо - увеличиваем координату
  }
  else
  {
    HD_CURSOR -= step;          // Влево - уменьшаем координату
  }
  
  for(i=0;i<step;i++)
  {
    HD_BUFFER[i] = data;                        // Заполняем буфер
  }
  HD_COUNT = 0;                                 // Сбрасываем счетчик буффера
  HD_USER |= (HD_USER_START | HD_USER_BUSY);    // Выставляем флаг готовности к записи и занятости устройства
  return;
}
//*****************************************************
//*************Зажигаем светодиодную подсветку*********
//*****************************************************
void HD_SetBackLight(uint16_t br)
{
  LedSet(br);
  return;
}
//*****************************************************
//*******************Очищаем дисплей*******************
//*****************************************************
void HD_CleanLCD(void)
{
  HD_BUFFER[0] = HD_CMD_CD;                     // Пишим команду
  HD_COUNT = 0;                                 // Сбрасываем счетчик буффера
  HD_USER |= (HD_USER_START | HD_USER_BUSY);    // Выставляем флаг готовности к записи и занятости устройства
  return;
}
//*****************************************************
//*****************Возвращаем корретку*****************
//*****************************************************
void HD_RetHome(void)
{
  HD_BUFFER[0] = HD_CMD_RH;                     // Пишим команду
  HD_COUNT  = 0;                                // Сбрасываем счетчик буффера
  HD_USER  |= (HD_USER_START | HD_USER_BUSY);   // Выставляем флаг готовности к записи и занятости устройства
  HD_CURSOR = 0;                                // Сбрасываем положение курсора
  return;
}
//*****************************************************
//*****************Перемещаем корретку*****************
//*****************************************************
void HD_MoveCur(uint8_t x)
{
  if (HD_CURSOR = x)    // Стоим на месте
  {
    return;
  }
  if (HD_CURSOR > x)    // двигаемся влево
  {
    HD_DispShift((HD_CURSOR-x),0);
    return;
  }
  if (HD_CURSOR < x)    // двигаемся вправо
  {
    HD_DispShift((x-HD_CURSOR),1);
    return;
  }
  return;
}
//*****************************************************
//******************Отобразить строку******************
//*****************************************************
void HD_WriteString(char* str)
{
  uint32_t i=0,j=0,n=0;
  
  HD_COUNT = 0;                 // Сбрасываем счетчик буффера
  HD_BUF_LEN = 0x30;
  n = 1;
  HD_BUFFER[0] = HD_CMD_RH;     // Возвращаем корретку
  for(i=0;i<8;i++)
  {
    HD_BUFFER[n] = ((uint8_t)str[j] | HD_BUFFER_RS_MSK);
    n++;
    j++;
  }
  for (i=0;i<32;i++)
  {
    HD_BUFFER[n]= HD_CMD_CDS | HD_CMD_CDS_RS;
    n++;
  }
  for(i=7;i<LSD_LEN;i++)
  {
    HD_BUFFER[n] = ((uint8_t)str[j] | HD_BUFFER_RS_MSK);
    n++;
    j++;
  }
  HD_USER |= (HD_USER_START | HD_USER_BUSY);    // Выставляем флаг готовности к записи и занятости устройства
  return;
}

void HD_Send_Float(float fl)
{
  uint32_t i=0, j=0;                            // луп
  char  buffer[5]={' ',' ',' ',' ',' '};        // буффер для перевода числа в ANCII
  char  OUT[LSD_LEN];                           // выходной буффер
  
  for(i=0;i<LSD_LEN;i++)
  {
    OUT[i] = 0x20;                       // Очищаем буфер
  }
  if (fl < 1)                           // Переменная дробная
  {
    sprintf(buffer, "%1.0E", fl);       // Переводим числов в АНСИ в виде aЕ-b
    buffer[3] = buffer[4];              // Убираем лишний ноль
    buffer[4] = 0x20;                   // Заполняем лишний символ пробелом
  }
  else                                  // Переменная целая
  {
    sprintf(buffer, "%.0f", fl);        // Переводим в обычном формате
    for (i=0; i<5; i++)
    {
      if (buffer[i] < 0x30 || buffer[i] > 0x39) buffer[i] = 0x20;  
    }
  }
  // Собираем сообщение по ТЗ
  OUT[3] = 'N';
  OUT[5] = 0x3D;  // =
  for (i=0;i<5;i++)
  {
    j=7+i;
    OUT[j] = buffer[i];
  }
  OUT[12] = '%';
  HD_WriteString(OUT);
  return;
}

void HD_DEMO(void)
{
  HD_WriteString("**HELLO WORLD!**");
  return;
}