//******************************************************************************
//*****************************INCLUDE******************************************
//******************************************************************************
#include "stm32f10x.h"
#include "TSP_SH.h"
#include "SPI.h"
#include "ADC.h"
#include "PWM.h"
#include "DIO.h"
#include "system.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_gpio.h"
#include "Register.h"
//******************************************************************************
//******************************************************************************
//******************************************************************************
#if (device == TSP_SH)
//******************************************************************************
//*******************************GLOBAL VAR*************************************
//******************************************************************************
static uint16_t         IndiData[DigNum];       // Данные на поссылку
static uint16_t         Bright  = BrDef;        // Яркость индикации
static uint8_t          CR      = 0;            // Регистр флажков
static uint16_t         SW_BUF  = 0;
//******************************************************************************
//*********************************CONST****************************************
//******************************************************************************
const uint16_t DigAdr[4] = {DIG01,DIG23,DIG45,DIG6};
//******************************************************************************
//*******************************FUNCTIONS**************************************
//******************************************************************************

//******************************************************************************
//******************************************************************************
//******************************************************************************
void TSP_SH_Init(void)
{  
  uint8_t i;

  for(i=0;i<DigNum;i++)
  {
    IndiData[i]=0x00;
  }
  WriteShortToHolding(BR,BrDef);
  
  RCC->APB2ENR |= RCC_APB2ENR_IOPAEN|RCC_APB2ENR_IOPBEN;        // Запускаем тактирование GPIOА и GPIOB
  RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;                           // Запускаем тактирование TIM3
  
  SPI_init(0);
  #if (ADC_OnOff)
    ADC_init();
  #endif
  DOUT_Init(nOE_pin,nOE_Port);
  PWM_Inin(BR_SW_pin,BR_SW_port,TIM3,3);
  SetPWM(TIM3, 3, Bright);
  nOE_RESET;
  SPI_Send(IndiData,DigNum);
  return;
}



void TSP_SH_FSA(void)
{
  
  uint8_t ModifyFlag = GetHoldingModifyFlag();  // Читаем флаг записи в регистры
  uint16_t buf;
  
  uint8_t l = 0;
  //****************************************************************************
  if (ModifyFlag)               // Если были изменения...
  {
    ResetHoldingModifyFlag();   // Сбрасываем флаг модификации регистров
    ModifyFlag--;               // Для обработки к модифити флагу прибавляют еденицу, вычитаем ее.
    switch(ModifyFlag)          // Перебираем адресса в памяти
    {
      //************************************************************************
      case DIG01:                                       // Если изменения в зажигании сегментов
        buf = ReadHolding(ModifyFlag);                  // Считываем данные из буфера
        IndiData[6] = (uint8_t)(buf&0x00FF);            // Вычитываем младший регистр
        IndiData[5] = (uint8_t)((buf&0xFF00)>>8);       // Вычитываем старший
        CR |= CR_NewData;                               // Выставляем флаг записи в данных в SPI
        break;
      case DIG23:                                       // Аналогично для остальных сегментов...
        buf = ReadHolding(ModifyFlag);
        IndiData[4] = (uint8_t)(buf&0x00FF);
        IndiData[3] = (uint8_t)((buf&0xFF00)>>8);
        CR |= CR_NewData;
        break;
      case DIG45:
        buf = ReadHolding(ModifyFlag);
        IndiData[2] = (uint8_t)(buf&0x00FF);
        IndiData[1] = (uint8_t)((buf&0xFF00)>>8);
        CR |= CR_NewData;
        break;
      case DIG6:
        buf = ReadHolding(ModifyFlag);
        IndiData[0] = (uint8_t)(buf&0x00FF);
        CR |= CR_NewData;
        break;
      //************************************************************************
      case SW01:                                // Если пытались записать в регистр кнопок
        buf = ReadHolding(ModifyFlag);          // Читаем, что записанно...
        if (buf != SW_BUF)                      // Если обновление произведенно пользователем
        {
          WriteShortToHolding(SW01,SW_BUF);     // Востанавливаем данные
        }
        break;
      //************************************************************************
      case BR:                          // Если изменили яркость..
        Bright = ReadHolding(BR);       // Считываем яркость из регистра
        CR |= CR_NewBr;                 // Ставим флажок обновления ШИМ
        break;
      //************************************************************************
    }
  }
  else  // Переходим на следующем заходе в прирывание к обработке HMI
  {
    //**************LIGHT*************************
    if ((CR & CR_NewData) && SPI_IsTxEnd())     // Если сформированны новые данные и предыдущая передача по SPI окончена...
    {
      SPI_Send(IndiData,DigNum);                // Запускаем пакетную передачу по SPI
      CR &= ~CR_NewData;                        // Снимаем флаг готовности новых данных
    }
    //***********BRIGHTNESS***********************
    else if (CR & CR_NewBr)                     // В случае если нужно изменить яркость...
    {
      SetPWM(TIM3, 3, Bright);                  // Записываем новое значение скважности ШИМ
      CR &= ~CR_NewBr;                          // Снимаем флаг новой яркости
    }
    //*************SW1*****************************
    if (SW1_READ && !(CR&CR_SW1))       // Если нажата кнопка №1 и не выставлен еще флаг нажатости
    {
      CR     |= CR_SW1;                 // Выставляем флаг нажатости 
      CR     |= CR_SW_CH;               // Выставляем флаг записи данных в холдинг
      SW_BUF |= SW1mask;                // Записываем маску кнопки №1 в буфер записи
    }
    else if(!SW1_READ && (CR&CR_SW1))   // Если не нажата кнопка №1 и не снят еще флаг нажатости
    {
      CR     &= ~CR_SW1;                // Снимаем флаг нажатости
      CR     |= CR_SW_CH;               // Выставляем флаг записи данных в холдинг
      SW_BUF &= ~SW1mask;               // Записываем маску кнопки №1 в буфер записи
    }
    //************SW1******************************
    if (SW2_READ && !(CR&CR_SW2))       // Если нажата кнопка №2 и не выставлен еще флаг нажатости
    {
      CR     |= CR_SW2;                 // Выставляем флаг нажатости 
      CR     |= CR_SW_CH;               // Выставляем флаг записи данных в холдинг
      SW_BUF |= SW2mask;                // Записываем маску кнопки №2 в буфер записи
    }
    else if(!SW2_READ && (CR&CR_SW2))   // Если не нажата кнопка №2 и не снят еще флаг нажатости
    {
      CR     &= ~CR_SW2;                // Снимаем флаг нажатости
      CR     |= CR_SW_CH;               // Выставляем флаг записи данных в холдинг
      SW_BUF &= ~SW2mask;               // Записываем маску кнопки №2 в буфер записи
    }
    //**********WRIGHT SW TO HOLDING***************
    if (CR & CR_SW_CH)                  // Если надо записать в холдинг статус кнопок
    {
      CR &= ~CR_SW_CH;                  // Снимаем фдаг обновления данных о кнопках
      WriteShortToHolding(SW01,SW_BUF); // Пишим данные из буффера
    }
    //*********************************************
  }
  return;
}
//******************************************************************************
//******************************************************************************
//******************************************************************************
#endif