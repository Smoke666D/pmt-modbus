//******************************************************************************
//*****************************INCLUDE******************************************
//******************************************************************************
#include "stm32f10x.h"
#include "BKC01.h"
#include "I2C.h"
#include "HD44780.h"
#include "Register.h"
#include "stm32f10x_tim.h"
#include "stm32f10x_rcc.h"
#include "system.h"
//******************************************************************************
//*******************************GLOBAL VAR*************************************
//******************************************************************************
static uint16_t         SysReg       = 0;
static uint8_t          LastEvent    = 0;
static uint32_t         SW_timer     = 0;       // Счетчик удержания кнопки
static uint32_t         SW_HoldTimer = 0;
static uint8_t          SW_acc       = 0;       // Память удержаной кнопки
static uint8_t          BIP_count    = 0;       // Счетчик гудков
static uint8_t          BIP_num      = 0;       // Кол-во гудков
static uint8_t          BIP_state    = 0;       // 0 - гудим, 1 - молчим
static uint16_t         LED_Br       = 0xFFFF;  // Яркость подсветки дисплея
//*****************************Счетчики*****************************************
static uint32_t         Change_time = 0;        // Счетчик времени, прошедшего с последнего изменения уставки 
static uint32_t         Ltime       = 0;        // Прошедшее время 
static uint8_t          SW_ActCount = 0;        // Счетчик выполненных действий при удержании кнопки
static uint8_t          SW_blockAct = 0;
static uint32_t         BIP_time    = 0;        // счетчик времени зума
static uint32_t         LED_time    = 0;
static uint32_t         LCD_time    = 0;
//******************************Уставка*****************************************
static float            SPtr            = 0.0;      // То что отправляем 
static float            SPtrTemp        = 0.0;      // То что отправляем 
static uint32_t         SetPointPos     = 0;        // Тут храним номер значения уставки
static uint32_t         SetPointPosTemp = 0;        // Тут храним номер значения уставки
//******************************************************************************
//*********************************CONST****************************************
//******************************************************************************
const float SetPointVal[SumUpSetPointNom] = 
{
  1E-8, 2E-8, 3E-8, 4E-8, 5E-8, 6E-8, 7E-8, 8E-8, 9E-8, 
  1E-7, 2E-7, 3E-7, 4E-7, 5E-7, 6E-7, 7E-7, 8E-7, 9E-7,
  1E-6, 2E-6, 3E-6, 4E-6, 5E-6, 6E-6, 7E-6, 8E-6, 9E-6,
  1E-5, 2E-5, 3E-5, 4E-5, 5E-5, 6E-5, 7E-5, 8E-5, 9E-5,
  1E-4, 2E-4, 3E-4, 4E-4, 5E-4, 6E-4, 7E-4, 8E-4, 9E-4,
  1E-3, 2E-3, 3E-3, 4E-3, 5E-3, 6E-3, 7E-3, 8E-3, 9E-3,
  1E-2, 2E-2, 3E-2, 4E-2, 5E-2, 6E-2, 7E-2, 8E-2, 9E-2,
  1E-1, 2E-1, 3E-1, 4E-1, 5E-1, 6E-1, 7E-1, 8E-1, 9E-1,
  1.0,  2.0,  3.0,  4.0,  5.0,  6.0,  7.0,  8.0,  9.0,  10.0,
  11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0,
  21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0,
  31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, 40.0,
  41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0, 48.0, 49.0, 50.0,
  51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0,
  61.0, 62.0, 63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0,
  71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0, 78.0, 79.0, 80.0,
  81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0, 88.0, 89.0, 90.0,
  91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 100.0,
  101.0, 102.0, 103.0, 104.0, 105.0, 106.0, 107.0
}; // Отсюда берем значение уставки, исходя из порядкового номера
//******************************************************************************
//*******************************FUNCTIONS**************************************
//******************************************************************************
uint8_t ScanSwitch(void);               // Сканирование нажатой кнопки, возвращает номер кнопки
uint8_t CheckSwitch(uint8_t sw);        // Проверка длительности нажатия кноки
void    ProcSw(void);                   // Общее для кнопок
void    Bip(uint8_t OnOff);             // Гудок (1-вкл, 0-выкл)
void    Led(uint8_t OnOff);             // Подсветка (1-вкл, 0-выкл)
void    TIM4_IRQHandler(void);          // Прерывание таймера 4
//******************************************************************************
//******************************************************************************
//******************************************************************************
uint8_t ScanSwitch(void)
{
  uint8_t input = 0;
  //**********************READ SW************************
  if (!KL1_READ)
  {
    input |= 0x01;
  }
  if (!KL2_READ)
  {
    input |= 0x02;
  }
  if (!KL3_READ)
  {
    input |= 0x04;
  }
  if (!KL4_READ)
  {
    input |= 0x08;
  }
  if (!KL5_READ)
  {
    input |= 0x10;
  }
  //*******************SWITCH PARSING********************
  switch (input)
  {
    case 0x00:          // Не нажата не одна кнопка
      return 0;
    case 0x01:
      return 0x01;      // 1-ая кнопка
    case 0x02:
      return 0x02;      // 2-ая кнопка
    case 0x04:
      return 0x03;      // 3-яя кнопка
    case 0x08:
      return 0x04;      // 4-ая кнопка
    case 0x10:
      return 0x05;      // 5-ая кнопка
    default:
      return 0x0F;      // Множественное нажатие - ошибка
  }
}
//******************************************************************************
//******************************************************************************
//******************************************************************************
uint8_t CheckSwitch(uint8_t sw)
{
  uint8_t out = 0;
  
  if (SW_acc != sw)             // Если нажата новая кнопка
  {
    SW_acc   = sw & SW_msk;     // Запоминаем ее в акумуляторе, отсеевая лишние данные
    out      = 0;               // Записываем в ответ пустое значение
    SW_timer = 0;               // Сбрасываем счетчик
  }
  else                          // Если кнопка удерживаеться
  {
    if (SW_timer > KeyDownTimout)// Если таймаут по дребезгу превыен...
    {
      out = SW_acc;             // Считаем, что кнопка сработала
    }
    if (SW_timer > KeyHoldTimeout)// Если таймаут по удержанию...
    {
      out |= SW_Hold;           // Отмечаем, что кнопка удерживаеться
    }
  }
  return out;
}
//******************************************************************************
//******************************************************************************
//******************************************************************************
void ProcSw(void)
{
  Ltime   = 0;                  // Сброим время для энергосберегающего режима (экран)
  SysReg |= SysRegBIPx1;        // Коротко пикнем
  Led(1);                       // Вкл подсветку
  return;
}
//******************************************************************************
//******************************************************************************
//******************************************************************************
void Bip(uint8_t OnOff)
{
  if (OnOff)
  {
    //PWM_tim->CCR4 = ZUMMER_freq;
    PWM_tim->CCR4 = PWM_tim->CNT/2;
  }
  else
  {
    PWM_tim->CCR4 = 0x0000;
  }
  return;
}
//******************************************************************************
//******************************************************************************
//******************************************************************************
void Led(uint8_t OnOff)
{
  if (OnOff)
  {
    //DOUT_SET(LED_port,LED_pin); // Зажигаем подсветку
    PWM_tim->CCR3 = LED_Br;
    SysReg |= SysRegLed;        // Выставляем флаг для окончание гороения
  }
  else
  {
    //DOUT_RESET(LED_port,LED_pin);
    PWM_tim->CCR3 = 0;
  }
  return;
}
//******************************************************************************
//*******************************INIT*******************************************
//******************************************************************************
void BKC01_Init(void)
{
  GPIO_InitTypeDef              GPIO_InitStruct;        // Структура инициализирующих данных GPIO
  TIM_OCInitTypeDef             TIM_OCConfig;           // Конфигурация выхода таймера
  TIM_TimeBaseInitTypeDef       TIM_BaseConfig;         // Структура инициализации часов
  //********************************RCC*****************************************
  RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
  RCC->APB1ENR |= RCC_APB1Periph_TIM2;
  //******************************DIN-DOUT**************************************
  DIN_Init(KL1_pin,KL1_port);           // Инициализация кнопки
  DIN_Init(KL2_pin,KL2_port);           // Инициализация кнопки
  DIN_Init(KL3_pin,KL3_port);           // Инициализация кнопки
  DIN_Init(KL4_pin,KL4_port);           // Инициализация кнопки
  DIN_Init(KL5_pin,KL5_port);           // Инициализация кнопки
  DIN_Init(KEY_pin,KEY_port);           // Инициализация кнопки  
  //DOUT_Init(LED_pin,LED_port);          // Включалка светодтиодной подсветки на дисплее
  //****************************************************************************
  //*********************************PWM****************************************
  //****************************************************************************
  //********************************GPIO****************************************
  GPIO_InitStruct.GPIO_Pin     = ZUM_pin;               // Настройки вывода PB11
  GPIO_InitStruct.GPIO_Mode    = GPIO_Mode_AF_PP;       // Режим альтернативной функции
  GPIO_InitStruct.GPIO_Speed   = GPIO_Speed_50MHz;      // Скорость порта максимальная
  GPIO_Init(ZUM_port, &GPIO_InitStruct);                // Заданные настройки сохраняем в регистрах GPIOB
  AFIO->MAPR |= AFIO_MAPR_TIM2_REMAP;                   // Ремапим выводы CH1-PA15,CH2-PB3, CH3-PB10, CH4-PB11
  //***************************LCD_CONTRAST*************************************
  GPIO_InitStruct.GPIO_Pin     = VO_pin;                // Настройки вывода PB11
  GPIO_Init(VO_port, &GPIO_InitStruct);                 // Заданные настройки сохраняем в регистрах GPIOB
  AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_JTAGDISABLE;          // Ремапим пин ДЖЕТага
  //*****************************LCD_LED****************************************
  GPIO_InitStruct.GPIO_Pin     = LED_pin;               // Настройки вывода PB11
  GPIO_Init(LED_port, &GPIO_InitStruct);                // Заданные настройки сохраняем в регистрах GPIOB
  //******************************TIM_2*****************************************
  TIM_OCStructInit(&TIM_OCConfig);                      // Стадартная инициализация структуры инициализации
  TIM_TimeBaseStructInit(&TIM_BaseConfig);              // Стадартная инициализация структуры инициализации
  TIM_BaseConfig.TIM_Prescaler     = 720;               // Предделитель 1 
  TIM_BaseConfig.TIM_ClockDivision = TIM_CKD_DIV1;      // Делитель частот 1
  TIM_BaseConfig.TIM_Period        = 100;              // Частота шима
  TIM_BaseConfig.TIM_CounterMode   = TIM_CounterMode_Up;// Отсчет от нуля до TIM_Period
  TIM_TimeBaseInit(PWM_tim, &TIM_BaseConfig);           // Инициализируем таймер №2
  //******************************TIM_CH****************************************
  TIM_OCConfig.TIM_OCMode      = TIM_OCMode_PWM1;       // Конфигурируем выход таймера, режим - PWM1   
  TIM_OCConfig.TIM_OutputState = TIM_OutputState_Enable;// Собственно - выход включен
  TIM_OCConfig.TIM_OCPolarity  = TIM_OCPolarity_High;   // Полярность => пульс - это единица (+3.3V)
  TIM_OCConfig.TIM_Pulse       = 0x0000;                // Пульс длинной
  TIM_OC4Init(PWM_tim, &TIM_OCConfig);                  // Инициализируем 4 выход таймера
  TIM_OCConfig.TIM_Pulse       = 0;                     // Пульс длинной
  TIM_OC1Init(PWM_tim, &TIM_OCConfig);                  // Инициализируем 1 выход таймера
  TIM_OC3Init(PWM_tim, &TIM_OCConfig);                  // Инициализируем 3 выход таймера
  TIM_CtrlPWMOutputs(PWM_tim, ENABLE);                  // Включаем ШИМ выхода  
  TIM_Cmd(PWM_tim, ENABLE);                             // Включаем таймер
  //****************************************************************************
  //********************************TIM4****************************************
  //****************************************************************************
  RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;                   // Тактирование таймера TIM4
  TIM4->CR1     = TIM_CR1_URS;                          // Сброс настроек 1
  TIM4->CR2     = 0;                                    // Сброс настроек 2
  TIM4->CNT     = 0;                                    // Сброс счетчика
  TIM4->PSC     = 72;                                   // Настройка предделителя таймера
  TIM4->ARR     = 100;                                  // Загружаем число миллисекунд в регистр автоперезагрузки
  TIM4->SR      = 0;                                    // Сброс статусов
  TIM4->DIER   |= TIM_DIER_UIE;                         // Разрешаем прерывание при переполнении счетчика
  NVIC_EnableIRQ(TIM4_IRQn);                            // Включаем прерывания по переполнению
  TIM4->EGR     = TIM_EGR_UG;                           // Считаем вверх 
  TIM4->CR1    |= TIM_CR1_CEN;                          // Запускаем счет
  //****************************************************************************
  //****************************************************************************
  //****************************************************************************
  return;
}

void BKC01_FunInit(void)
{
  HD_init();                                            // Инициализируем дисплей
  SetPointPos = ReadHolding(SetPointAdr);               // Читаем номер уставки из памяти
  PWM_tim->CCR1   = ReadHolding(LCD_ContrastAdr);       // Меням контраст экрана
  //PWM_tim->CCR1 = (PWM_tim->CNT)*(ReadHolding(LCD_ContrastAdr) & 0xF)/0xF;
  //LED_Br        = (PWM_tim->CNT)*(ReadHolding(LCD_BrightAdr)   & 0xF)/0xF;
  SetPointPosTemp = SetPointPos;
  SPtr = SetPointVal[SetPointPos];                      // Инициализирекм уставку
  SPtrTemp = SPtr;
  HD_Send_Float(SPtr);                                  // Выводим на дисплей сохраненную уставку
}


//******************************************************************************
//********************************FSA*******************************************
//******************************************************************************
//       |---|
//       | 1 |
//       |---|
// |---| |---| |---|
// | 3 | | 5 | | 4 |   Расположение кнопок на приборе
// |---| |---| |---|
//       |---|
//       | 2 |
//       |---|
void BKC01_FSA(void)
{
  uint8_t SwTrg   = 0;                    // Сработавшая кнопка
  
  if (GetHoldingModifyFlag())
  {
    SetPointPos     = ReadHolding(SetPointAdr);         // Читаем уставку из памяти
    SetPointPosTemp = SetPointPos;                      // Затираем изменение уставки
    SPtr            = SetPointVal[SetPointPos];         // Вычисляем значение уставки
    SPtrTemp        = SPtr;                             // Затираем изменение уставки
    HD_Send_Float(SPtr);                                // Выводим на дисплей сохраненную уставку
    
    PWM_tim->CCR1   = ReadHolding(LCD_ContrastAdr);     // Меням контраст экрана
    LED_Br          = ReadHolding(LCD_BrightAdr);       // Меняем яркость экрана
    
    ResetHoldingModifyFlag();                           // Сбрасываем флаг приема новых данных
  }
  else
  {
    if (!KEY_READ)                              // Если ключ повернут
    {
      if (!(SysReg & SysRegKey))                // Ключ только повернули
      {
        Led(1);                                 // Включаем подсветку
        //Режим изменения уставки
        SysReg |= SysRegKey;                    // Отмечаем, что ключ удерживаеться в положении
      }
      SwTrg   = CheckSwitch(ScanSwitch());      // Сканируем нажатые кнопки и Отсекаем дребезг контактов
      if(LastEvent != SwTrg)                    // Если предыдущее событие не повторяеться
      {
        LastEvent = SwTrg;                      // Записываем новое событие
        SysReg   |= SysRegSwDone;               // Выставляем флажок нового события
      }
      if (((LastEvent&SW_msk) == 0x0F)&&((SwTrg&SW_msk) != 0)&&((SwTrg&SW_msk != 0x0F)))
      {
        SwTrg = 0x0A;
      }
      switch(SwTrg)                                     // Обработка кнопки
      {
        case 0x00:                                      // Обработка кнопки не закончена
          break;
        case 0x0F:                                      // Ошибка множественного нажатия
          if (SysReg & SysRegSwDone)
          {
            SysReg |= SysRegBIPx3;                      // Пикнуть
            SysReg &= ~SysRegSwDone;
          }
          break;
        //**********************************************************************  
        case 0x01:                                      // Кнопка №1 - вверх
          if (SysReg & SysRegSwDone)                    // Если обработка не была выполнена
          {
            if (SysReg & SysRegBlink)                   // Если режим изменения уставки
            {
              SW_ActCount = 0;
              SW_blockAct = 0;
              SysReg &= ~SysRegBlink;                   // Запрещаем мигание
              if(SetPointPosTemp < (SumUpSetPointNom-1))// Если есть куда увеличивать уставку
              {
                Ltime   = 0;                            // Сброим время для энергосберегающего режима (экран)
                SysReg |= SysRegBIPx1;                  // Коротко пикнем
                Led(1);                                 // Вкл подсветку
                SetPointPosTemp++;                      // Инкрементируем позицию
                SPtrTemp = SetPointVal[SetPointPosTemp];// Вычисляем уставку
                SysReg  |= SysRegChange;                // Ставим флажек изменения уставки
                Change_time = 0;                        // Сбрасываем счетчик времени последнего изменения
                HD_Send_Float(SPtrTemp);                // Выводим уставку на дисплей
                SysReg |= SysRegBlink;                  // Разрешаем мигание
              }
              else
              {
                Ltime   = 0;                            // Сброим время для энергосберегающего режима (экран)
                SysReg |= SysRegBIPx2;                  // Коротко пикнем
                Led(1);                                 // Вкл подсветку
              }
            }
            else
            {
              Ltime   = 0;                              // Сброим время для энергосберегающего режима (экран)
              SysReg |= SysRegBIPx1;                    // Коротко пикнем
              Led(1);                                   // Вкл подсветку
            }
            SysReg &= ~SysRegSwDone;                    // Снимаем флаг нового события
          }
          break;
        case 0x11:                                      // Кнопка №1 с залипанием 
          if (((SW_ActCount < ShortToLongCount) && (SW_HoldTimer > KeyHoldLongTimeout)) || ((((SW_ActCount+1) > ShortToLongCount) && (SW_HoldTimer > KeyHoldShortTimeout))))
          {
            SW_ActCount++;
            SW_HoldTimer = 0;
            Ltime   = 0;                                // Сброим время для энергосберегающего режима (экран)
            Led(1);                                     // Вкл подсветку
            if(SetPointPosTemp < (SumUpSetPointNom-1))  // Если есть куда увеличивать уставку
            {
              SetPointPosTemp++;                        // Инкрементируем позицию
              SPtrTemp = SetPointVal[SetPointPosTemp];  // Вычисляем уставку
              SysReg  |= SysRegChange;                  // Ставим флажек изменения уставки
              Change_time = 0;                          // Сбрасываем счетчик времени последнего изменения
              HD_Send_Float(SPtrTemp);                  // Выводим уставку на дисплей
              SysReg |= SysRegBlink;                    // Разрешаем мигание
            }
            else if (!SW_blockAct)
            {
              Ltime   = 0;                              // Сброим время для энергосберегающего режима (экран)
              SysReg |= SysRegBIPx2;                    // Коротко пикнем
              Led(1);                                   // Вкл подсветку
              SW_blockAct = 1;
            }
          }
          break;
        //**********************************************************************  
        case 0x02:                                      // Кнопка №2 - вниз
          if (SysReg & SysRegSwDone)                    // Если обработка не была выполнена
          {
            if (SysReg & SysRegBlink)                   // Если режим изменения уставки
            {
              SW_ActCount = 0;
              SW_blockAct = 0;
              SysReg &= ~SysRegBlink;                   // Запрещаем мигание
              if(SetPointPosTemp > 0)                   // Если есть куда уменьшать уставку
              {
                Ltime   = 0;                            // Сброим время для энергосберегающего режима (экран)
                SysReg |= SysRegBIPx1;                  // Коротко пикнем
                Led(1);                                 // Вкл подсветку
                SetPointPosTemp--;                      // Инкрементируем позицию
                SPtrTemp = SetPointVal[SetPointPosTemp];// Вычисляем уставку
                SysReg  |= SysRegChange;                // Ставим флажек изменения уставки
                Change_time = 0;                        // Сбрасываем счетчик времени последнего изменения
                HD_Send_Float(SPtrTemp);                // Выводим уставку на дисплей
                SysReg |= SysRegBlink;                  // Разрешаем мигание
              }
              else
              {
                Ltime   = 0;                            // Сброим время для энергосберегающего режима (экран)
                SysReg |= SysRegBIPx2;                  // Коротко пикнем
                Led(1);                                 // Вкл подсветку
              }
            }
            else
            {
              Ltime   = 0;                              // Сброим время для энергосберегающего режима (экран)
              SysReg |= SysRegBIPx1;                    // Коротко пикнем
              Led(1);                                   // Вкл подсветку
            }
            SysReg &= ~SysRegSwDone;                    // Снимаем флаг нового события
          }
          break;
        case 0x12:                                      // Кнопка №2 с залипанием
          if (((SW_ActCount < ShortToLongCount) && (SW_HoldTimer > KeyHoldLongTimeout)) || ((((SW_ActCount+1) > ShortToLongCount) && (SW_HoldTimer > KeyHoldShortTimeout))))
          {
            SW_ActCount++;
            SW_HoldTimer = 0;
            Ltime        = 0;                           // Сброим время для энергосберегающего режима (экран)
            Led(1);                                     // Вкл подсветку
            if(SetPointPosTemp > 0)                     // Если есть куда увеличивать уставку
            {
              SetPointPosTemp--;                        // Инкрементируем позицию
              SPtrTemp = SetPointVal[SetPointPosTemp];  // Вычисляем уставку
              SysReg  |= SysRegChange;                  // Ставим флажек изменения уставки
              Change_time = 0;                          // Сбрасываем счетчик времени последнего изменения
              HD_Send_Float(SPtrTemp);                  // Выводим уставку на дисплей
              SysReg |= SysRegBlink;                    // Разрешаем мигание
            }
            else if (!SW_blockAct)
            {
              Ltime   = 0;                              // Сброим время для энергосберегающего режима (экран)
              SysReg |= SysRegBIPx2;                    // Коротко пикнем
              Led(1);                                   // Вкл подсветку
              SW_blockAct = 1;
            }
          }
          break;
        //**********************************************************************  
        case 0x03:                                      // Кнопка №3 - влево
          if (SysReg & SysRegSwDone)                    // Если обработка не была выполнена
          {
            ProcSw();                                   // Пикнуть, зажечь подсветку дисплея
            SysReg     &= ~SysRegBlinkStat;             // Ничминаем с гашения
            SysReg     ^= SysRegBlink;                  // Меняем режим изменения уставки
            SysReg     &= ~SysRegSwDone;                // Снимаем флаг нового события
            Change_time = 0;                            // Сбрасываем счетчик времени последнего изменения
            if (!(SysReg & SysRegBlink))
            {
              SetPointPosTemp = SetPointPos;            // Стираем номер уставки
              SPtrTemp = SPtr;                          // Стираем изменения уставки
              HD_Send_Float(SPtr);                      // Выводим уставку на индикатор
            }
          }
          break;
        case 0x13:                                      // Кнопка №3 с залипанием
          break;
        //**********************************************************************  
        case 0x04:                                      // Кнопка №4 - вправо
          if (SysReg & SysRegSwDone)                    // Если обработка не была выполнена
          {
            ProcSw();                                   // Пикнуть, зажечь подсветку дисплея
            SysReg &= ~SysRegBlinkStat;                 // Ничминаем с гашения
            SysReg ^= SysRegBlink;                      // Меняем режим изменения уставки
            SysReg &= ~SysRegSwDone;                    // Снимаем флаг нового события
            Change_time = 0;                            // Сбрасываем счетчик времени последнего изменения
            if (!(SysReg & SysRegBlink))                // Если произошел выход из режима уставки
            {
              SetPointPosTemp = SetPointPos;            // Стираем номер уставки
              SPtrTemp = SPtr;                          // Стираем изменения уставки
              HD_Send_Float(SPtr);                      // Выводим уставку на индикатор
            }
          }
          break;
        case 0x14:                                      // Кнопка №4 с залипанием
          break;
        //**********************************************************************  
        case 0x05:                                              // Кнопка №5 - ентер
          if (SysReg & SysRegSwDone)                            // Если обработка не была выполнена
          {
            ProcSw();                                           // Пикнуть, зажечь подсветку дисплея
            SetPointPos = SetPointPosTemp;
            SysReg &= ~SysRegBlink;                             // Запрещаем мигание
            SPtr = SetPointVal[SetPointPos];                    // Записываем в запаску уставку
            SPtr = SPtrTemp;
            WriteShortToHolding(SetPointAdr,SetPointPos);       // Записываем в запаску уставку
            ResetHoldingModifyFlag();
            HD_Send_Float(SPtr);                                // Выводим уставку на индикатор
            SysReg &= ~SysRegSwDone;                            // Снимаем флаг нового события
          }
          break;
        case 0x15:                                      // Кнопка №5 с залипанием
          break;
      }
    } //if (KEY_READ) 
    else
    {
      if (SysReg & SysRegKey)
      {
        SysReg &= ~(SysRegKey | SysRegBlink);
        SetPointPosTemp = SetPointPos;            // Стираем номер уставки
        SPtrTemp = SPtr;                          // Стираем изменения уставки
        HD_Send_Float(SPtr);                      // Выводим уставку на индикатор
        Led(0);
      }
    }
  }
  return;
}


void TIM4_IRQHandler(void)
{
  WatchDog_reset();
  if(TIM4->SR & TIM_SR_UIF)
  {
    __disable_irq ();
    //********************************SW****************************************
    SW_timer++;                 // Считаем время нажатия кнопки
    SW_HoldTimer++;
    //********************************LED***************************************
    if(SysReg & SysRegLed)
    {
      SysReg &= ~SysRegLed;
      LED_time = 0;
    }
    LED_time++;
    if (LED_time >= LED_TIMEOUT)
    {
      Led(0);
    }    
    //*******************************CHANGE*************************************
    Change_time++;
    if ((Change_time > WaitChTimeout) && (SysReg & SysRegBlink))
    {
      SysReg &= ~SysRegBlink;           // Выходим из режима изменения
      SetPointPosTemp = SetPointPos;
      SPtrTemp = SPtr;
      HD_Send_Float(SPtr);              // Выводим на дисплей сохраненную уставку
    }
    //*******************************LCD****************************************
    LCD_time++;
    if ((SysReg & SysRegBlink) && (LCD_time > LCD_TIMEOUT) && (SysReg & SysRegBlinkStat))
    {
      HD_WriteString("                ");      // Очищаем дисплей
      SysReg ^= SysRegBlinkStat;
      LCD_time = 0;
    }
    if ((SysReg & SysRegBlink) && (LCD_time > (LCD_TIMEOUT/1.5)) && (!(SysReg & SysRegBlinkStat)))
    {
      HD_Send_Float(SPtrTemp);                  // Выводим уставку на дисплей
      SysReg ^= SysRegBlinkStat;
      LCD_time = 0;
    }
    //*******************************BIP****************************************
    if (SysReg & SysRegBIPx1)
    {
      BIP_num   = 1;            // Считать гудки до одного
      BIP_count = 0;            // Сбросить счетчик гудков
      SysReg &= ~SysRegBIPx1;   // Сбрасываем флаг задания
      BIP_time  = 0;            // Сбрасываем счетчик интервала гудка/молчаничя
      BIP_state = 0;            // Начинаем с гудка
      Bip(1);                   // Начинаем гудеть
    }
    if (SysReg & SysRegBIPx2)
    {
      BIP_num   = 2;            // Считать гудки до двух
      BIP_count = 0;            // Сбросить счетчик гудков
      SysReg &= ~SysRegBIPx2;   // Сбрасываем флаг задания
      BIP_time  = 0;            // Сбрасываем счетчик интервала гудка/молчаничя
      BIP_state = 0;            // Начинаем с гудка
      Bip(1);                   // Начинаем гудеть
    }
    if (SysReg & SysRegBIPx3)
    {
      BIP_num   = 3;            // Считать гудки до трех
      BIP_count = 0;            // Сбросить счетчик гудков
      SysReg &= ~SysRegBIPx3;   // Сбрасываем флаг задания
      BIP_time  = 0;            // Сбрасываем счетчик интервала гудка/молчаничя
      BIP_state = 0;            // Начинаем с гудка
      Bip(1);                   // Начинаем гудеть
    }
    if (BIP_count < BIP_num)    // Пока не сосчитали нужное кол-во гудков
    {
      BIP_time++;                                       // Инкрементиркем счетчик мс
      if((!BIP_state) && (BIP_time > BIP_TIMEOUT))      // Если полупериод гудка закончен...
      {
        BIP_state = 1;                                  // Переходим в режим молчания
        Bip(0);                                         // Прекращаем гудеть
        BIP_time = 0;                                   // Сбрасываем счетчик
      }
      if((BIP_state) && (BIP_time > BIP_TIMEOUT))
      {
        BIP_state = 0;                                  // Переходим в режим гудка
        BIP_time = 0;                                   // Сбрасываем счетчик
        BIP_count++;                                    // Инкрементируем кол-во гудков
        if(BIP_count < BIP_num)                         // Отсекаем лишний звук
        {       
          Bip(1);                                       // Начинаем гудеть
        }
      }
    }
    //******************HD****************************
    HD_Proc();    // Обработка дисплея
    //*****************************I2C****************
    //I2C_Proc();   // Обработка интерфейса
    //************************************************
    __enable_irq ();
  }
  TIM4->SR = 0;
  return;
}
//******************************************************************************
//******************************************************************************
//******************************************************************************