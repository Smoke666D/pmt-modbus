//******************************************************************************
//*****************************INCLUDE******************************************
//******************************************************************************
#include "stm32f10x.h"
#include "BKC14.h"
#include "I2C.h"
//#include "system.h"
#include "Register.h"
//******************************************************************************
//*******************************GLOBAL VAR*************************************
//******************************************************************************
static uint8_t          mode                 = 1;                               // Режим программы, начинаем с чтения после включения
static uint8_t          I2C_time             = 0;                               // Счетчик времени между чтением регистров расшерителя портов
static uint16_t         data[RamNum/2];                                         // Данные на запись в память
static uint16_t         PrevData[RamNum/2];                                     // Записанные в предыдущий раз данные
static uint16_t         DevMemAdr[DevOnLine*2] = {0x00, 0x01, 0x00, 0x01, 0x00, 0x01};
static uint8_t          DevAdr[DevOnLine*2]  = {DevAdr0, DevAdr0, DevAdr1, DevAdr1, DevAdr2, DevAdr2};
static uint16_t         DataReg = 0;                                            // Буфер для запси доп регистра (Пока там только состояние кнопки первым битом)
//******************************************************************************
//*********************************CONST****************************************
//******************************************************************************
const uint8_t MemAdr[RamNum]    = {ValS1_1,ValS1_2,ValS2_1,ValS2_2,ValS3_1,ValS3_2};
//******************************************************************************
//*******************************FUNCTIONS**************************************
//******************************************************************************

//******************************************************************************
//*******************************INIT*******************************************
//******************************************************************************
void BKC14_Init(void)
{
  DIN_Init(SW_trig_pin,SW_port);        // Инициализация кнопки
  I2C_setup(2,100000,1,0);              // Объевляем устройство
  I2C_init();                           // Инициализируем интерфейс
  return;
}
//******************************************************************************
//********************************FSA*******************************************
//******************************************************************************
uint32_t I2C_timer = 0;
uint16_t temp;

void BKC14_FSA(void)
{
  uint8_t  i;
  uint16_t buf = 0;

  //*****************************I2C********************************************
  I2C_Proc();   // Обработка интерфейса
  //**************************************************************************** 
  if (GetHoldingModifyFlag())
  {
    ResetHoldingModifyFlag();                                                   // Сбрасываем флаг приема новых данных
  }
  else
  {
    
    #if (!SwRead)
        if(!DIN_READ(SW_port,SW_trig_pin) && (!(DataReg&SwOnMask)))
        {
          DataReg |= SwOnMask;
          WriteShortToHolding(SwAdr,DataReg);
        }
        else if (DIN_READ(SW_port,SW_trig_pin) && (DataReg&SwOnMask))
        {
          DataReg &= ~SwOnMask;
          WriteShortToHolding(SwAdr,DataReg);
        }
      #endif
    
    switch (mode)
    {
      //***************************SW TRIGER************************************
      case 0:
        #if (SwRead)
          if(!DIN_READ(SW_port,SW_trig_pin))
          {
            mode = 1;                                 // Переходим к ожиданию данных
            WriteShortToHolding(SwAdr,SwOnMask);
          }
          break;
        #else
          mode = 1;     // Переходим к ожиданию данных
        #endif
      //*************************WAIT I2C BUSY**********************************
      case 1:
        if (!I2C_GetBusy())
        {
          I2C_Read(DevAdr,DevMemAdr,DevOnLine*2);     // Запускаем чтение из регистров
          mode = 2;
        }
      //**************************DATA READY************************************
      case 2:
        if (!I2C_GetBusy())
        {
          for(i=0;i<(RamNum/2);i++)
          {
            data[i]  = (~(I2C_GetData())[i*2])&0x00FF;
            data[i] |= ((~(I2C_GetData())[i*2+1])&0x00FF)<<8;
          }
          mode = 3;
        }
        break;
      //************************DATA PARSING************************************
      case 3:
        for(i=0;i<(RamNum/2);i++)
        {
          if(PrevData[i] != data[i])
          {
            PrevData[i] = data[i];
            WriteShortToHolding(MemAdr[i*2],(data[i]&0x000F));
            data[i] = data[i] >> 4;
            buf = ((data[i]&0x000F) << 8) | ((data[i]&0x00F0) >> 4) | ((data[i]&0x0F00) >> 4);
            WriteShortToHolding(MemAdr[i*2+1],buf);
          }
        }
        mode = 4;
        break;
      //**************************DELAY*****************************************
      case 4:
        if(I2C_time < 5) 
        {
          I2C_time++;
        }
        else
        {
          mode = 0;
        }        
        break;
      //************************************************************************
    }
  }
  return;
}
//******************************************************************************
//******************************************************************************
//******************************************************************************